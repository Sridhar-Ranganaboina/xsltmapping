public override async Task ProcessAsync(TagHelperContext context, TagHelperOutput output)
{
    try
    {
        // Validate SearchType
        var validSearchTypes = new HashSet<string> { "equals", "not-equals", "greater-than", "less-than", "in-between" };
        if (string.IsNullOrEmpty(SearchType) || !validSearchTypes.Contains(SearchType))
        {
            throw new ArgumentException("Invalid or missing SearchType.");
        }

        // Render a dropdown for search type
        string dropdownHtml = $@"
            <select name='searchType'>
                <option value='equals' {(SearchType == "equals" ? "selected" : "")}>Equals</option>
                <option value='not-equals' {(SearchType == "not-equals" ? "selected" : "")}>Not Equal To</option>
                <option value='greater-than' {(SearchType == "greater-than" ? "selected" : "")}>Greater Than</option>
                <option value='less-than' {(SearchType == "less-than" ? "selected" : "")}>Less Than</option>
                <option value='in-between' {(SearchType == "in-between" ? "selected" : "")}>In Between</option>
            </select>";

        // Render a date picker or two date pickers for "In Between"
        string dateInputHtml;
        if (SearchType == "in-between")
        {
            dateInputHtml = "<input type='date' name='fromDate' placeholder='From Date' />" +
                            "<input type='date' name='toDate' placeholder='To Date' />";
        }
        else
        {
            dateInputHtml = "<input type='date' name='singleDate' placeholder='Date' />";
        }

        // Construct the HTML for the TagHelper output
        output.TagName = "div";
        output.Attributes.SetAttribute("class", "date-search-taghelper");
        output.Content.SetHtmlContent($"{dropdownHtml}{dateInputHtml}");
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Error processing DateSearchTagHelper: {Message}", ex.Message);
        output.Content.SetContent("Error rendering date search criteria.");
    }

    await base.ProcessAsync(context, output);
}
